syntax = "proto3";
package plugin.v1;

option go_package = "plugin/v1;pluginpb";

import "google/protobuf/struct.proto";

// Contract for on-demand plugins (CLI-invoked).
// At runtime the host and plugin exchange protobuf messages encoded as
// JSON (using `protojson`) over standard input/output.  This serializer is
// intentionally language-agnostic so plugins can be written in any language.
// Plugins SHOULD implement the PluginService
service PluginService {
  // Info returns basic information about the plugin (type, name, version, description).
  rpc Info(PluginV1.InfoRequest) returns (PluginV1.InfoResponse);

  // Exec executes a plugin-specific command (e.g. SQL/NoSQL query) and returns the result.
  // The core will pass user-provided connection details (e.g. host, user, password) and
  // the plugin will handle the execution and return a serialized result (string/json) or an error message.
  rpc Exec(PluginV1.ExecRequest) returns (PluginV1.ExecResponse);

  // AuthForms returns available authentication forms the plugin supports. The core
  // will render these forms (tabs) and send the selected form values back
  // to the plugin when creating a connection.
  rpc AuthForms(PluginV1.AuthFormsRequest) returns (PluginV1.AuthFormsResponse);

  // ConnectionTree returns a driver-defined hierarchy of nodes and actions for
  // a given connection.  The frontend uses this to render a browsable tree.
  rpc ConnectionTree(PluginV1.ConnectionTreeRequest) returns (PluginV1.ConnectionTreeResponse);

  // TestConnection verifies that the provided credentials can reach the data
  // store. Plugins MUST NOT persist any state; the call is fire-and-forget.
  // Plugins that cannot meaningfully test connectivity should return ok=true.
  rpc TestConnection(PluginV1.TestConnectionRequest) returns (PluginV1.TestConnectionResponse);
}

// PluginV1 defines the data structures for plugin information, execution, and authentication forms.
message PluginV1 {

  // Type defines the category of the plugin, which can be used by the core to determine how to handle it (e.g. render query editor for DRIVER plugins).
  enum Type {
    UNKNOWN = 0;
    DRIVER = 1; // Driver plugin (e.g. SQL databases like MySQL, Postgres)
  }

  message InfoRequest {}

  message InfoResponse {
    Type type = 1;
    string name = 2;
    string version = 3;
    string description = 4;
  }

  message ExecRequest {
    // connection is plugin-defined key/value (host, user, password, ...)
    map<string, string> connection = 1;
    string query = 2; // Query or plugin-specific payload (SQL/NoSQL/etc.)
  }

  // ExecResponse contains the output of an Exec call,
  // provide a typed, extensible envelope that can represent at least three
  // common data models (SQL, document/JSON, and simple key-value maps).  The
  // UI will examine the oneof field and render accordingly instead of relying
  // on plugin-specific semantics.
  message ExecResponse {
    ExecResult result = 1;
    string error = 2;  // optional error message
  }

  // ExecResult is a wrapper around the various result types supported by a
  // plugin.  Only one field will be populated.
  message ExecResult {
    oneof payload {
      SqlResult sql = 1;
      DocumentResult document = 2;
      KeyValueResult kv = 3;
    }
  }

  // SqlResult describes a tabular result set with explicit columns and rows.
  // All values are serialized as strings; plugins are free to format them as
  // they wish (e.g. quoting) but the UI will treat them generically.
  // Columns carry metadata about each field in a tabular SQL result.  Name is
  // required; type is optional and may reflect the database's type name (e.g.
  // "varchar", "int").  The UI can use this information to choose appropriate
  // input/edit controls when presenting results or constructing inserts.
  message Column {
    string name = 1;
    string type = 2;
  }

  message SqlResult {
    repeated Column columns = 1;
    repeated Row rows = 2;
  }

  message Row {
    repeated string values = 1;
  }

  // DocumentResult is intended for document‑oriented databases (Mongo, Couch,
  // etc.) where each entry is an object.  The google.protobuf.Struct type is
  // used here to avoid prescribing a schema – it maps cleanly to JS objects
  // and the frontend can iterate the fields dynamically.
  message DocumentResult {
    repeated google.protobuf.Struct documents = 1;
  }

  // KeyValueResult is a simple map of string→string appropriate for things like
  // Redis or other key/value stores where the “row” concept isn’t meaningful.
  message KeyValueResult {
    map<string, string> data = 1;
  }

  // AuthField represents a single input field for authentication (e.g. host, user, password).
  // The plugin defines the fields it needs for authentication and the core renders them accordingly.
  message AuthField {

    // FieldType defines the type of input field to render for authentication details.
    enum FieldType {
      FIELD_UNKNOWN = 0;
      TEXT = 1;
      NUMBER = 2;
      PASSWORD = 3;
      CHECKBOX = 4;
      SELECT = 5;
      FILE_PATH = 6;
    }

    FieldType type = 1; // input type
    string name = 2; // machine name (lower-case, no spaces)
    string label = 3; // human-friendly label
    string value = 4; // default/value used when invoking plugin
    bool required = 5; // whether field is required
    repeated string options = 6; // for select inputs
    string placeholder = 7; // optional placeholder
  }

  // AuthForm represents a set of fields for a specific authentication method (e.g. "basic", "oauth").
  // The core will render a tab per form and present the `fields` to the user. When the user submits
  // the form, the core will send the field values back to the plugin for connection/authentication.
  message AuthForm {
    string key = 1; // e.g. "basic"
    string name = 2; // e.g. "Basic"
    repeated AuthField fields = 3;
  }

  message AuthFormsRequest {}

  message AuthFormsResponse {
    // map key is the form `key` (e.g. "basic").
    map<string, AuthForm> forms = 1;
  }

  // ConnectionTreeRequest is sent when the frontend wants to browse a
  // connection.  The contents are purely driver-defined.
  message ConnectionTreeRequest {
    map<string,string> connection = 1;
  }

  message ConnectionTreeResponse {
    repeated ConnectionTreeNode nodes = 1;
  }

  // NodeType is an optional hint for the frontend icon renderer and lets Go
  // code reference well-known node kinds via generated constants instead of
  // raw strings.
  enum NodeType {
    NODE_TYPE_UNKNOWN    = 0; // generic / unspecified
    NODE_TYPE_DATABASE   = 1;
    NODE_TYPE_TABLE      = 2;
    NODE_TYPE_COLUMN     = 3;
    NODE_TYPE_SCHEMA     = 4;
    NODE_TYPE_VIEW       = 5;
    NODE_TYPE_ACTION     = 6; // indicates a leaf node that represents an action, not a database object
    NODE_TYPE_COLLECTION = 7; // for document stores like Mongo
    NODE_TYPE_KEY        = 8; // for key/value stores like Redis
  }

  message ConnectionTreeNode {
    string key       = 1;              // unique within the returned tree
    string label     = 2;              // user-visible text
    repeated ConnectionTreeNode children = 3;
    repeated ConnectionTreeAction actions = 4;
    NodeType node_type = 5;
  }

  message ConnectionTreeAction {
    string type   = 1; // machine name (e.g. "select", "describe")
    string title  = 2; // displayed in a context menu or double-click
    string query  = 3; // plugin-interpreted payload (often SQL)
    // hidden suppresses the action from the context menu / action buttons.
    // Use this for actions that should only fire on leaf-node click, not be
    // explicitly listed as selectable options.
    bool   hidden = 4;
    bool new_tab = 5; // whether the core should open a new tab when this action is executed
  }

  // TestConnectionRequest carries the same credential map as ExecRequest so
  // plugins can reuse their existing connection-building logic.
  message TestConnectionRequest {
    map<string, string> connection = 1;
  }

  // TestConnectionResponse indicates whether the connection attempt succeeded.
  // ok=true means the plugin could open and ping the data store.
  // message carries a human-readable success or failure description.
  message TestConnectionResponse {
    bool   ok      = 1;
    string message = 2;
  }
}
